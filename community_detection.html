
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Community detection &#8212; Network Data Science</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="_static/logo.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Network embedding" href="embedding.html" />
    <link rel="prev" title="Random network models" href="random_graphs.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-JYHFQNEPZN"></script>
<script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-JYHFQNEPZN');
                </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Network Data Science</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="landing.html">
                    Welcome
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Course logistics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="syllabus.html">
   Syllabus
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="calendar.html">
   Calendar
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mini_assignment.html">
   Mini-assignment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="final_project.html">
   Final project
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Resources
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="online_resources.html">
   Online
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="books.html">
   Books
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="datasets.html">
   Datasets
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Lectures
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference external" href="https://bdpedigo.github.io/networks-course/welcome.html">
   Welcome
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://bdpedigo.github.io/networks-course/what_are_networks.html">
   What are networks?
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="representing_networks.html">
   Representing networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="plotting_networks.html">
   Plotting networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="connected_components.html">
   Connected components
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="centrality.html">
   Centrality measures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="random_graphs.html">
   Random network models
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Community detection
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="embedding.html">
   Network embedding
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="graph_matching.html">
   Graph matching
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multiple_embedding.html">
   Embedding multiple networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ranking.html">
   Ranking and flow
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/bdpedigo/networks-course/main?urlpath=tree/docs/community_detection.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/bdpedigo/networks-course"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/bdpedigo/networks-course/issues/new?title=Issue%20on%20page%20%2Fcommunity_detection.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/bdpedigo/networks-course/edit/main/docs/community_detection.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/community_detection.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modularity">
   Modularity
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#naive-optimization">
     Naive optimization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spectral-optimization">
     Spectral optimization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#agglomerative-optimization-louvain-leiden">
     Agglomerative optimization - Louvain/Leiden
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#know-what-modularity-gives-you">
     Know what modularity gives you
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#issues-with-modularity-maximization">
     Issues with modularity maximization
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#resolution-limit">
       Resolution limit
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#overfitting">
       Overfitting
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#alternatives-to-modularity">
   Alternatives to modularity
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#infomap">
     InfoMap
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#statistical-inference-sbm-similar">
     Statistical inference (SBM + similar)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#other-code">
   Other code
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Community detection</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modularity">
   Modularity
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#naive-optimization">
     Naive optimization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spectral-optimization">
     Spectral optimization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#agglomerative-optimization-louvain-leiden">
     Agglomerative optimization - Louvain/Leiden
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#know-what-modularity-gives-you">
     Know what modularity gives you
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#issues-with-modularity-maximization">
     Issues with modularity maximization
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#resolution-limit">
       Resolution limit
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#overfitting">
       Overfitting
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#alternatives-to-modularity">
   Alternatives to modularity
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#infomap">
     InfoMap
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#statistical-inference-sbm-similar">
     Statistical inference (SBM + similar)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#other-code">
   Other code
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="community-detection">
<h1>Community detection<a class="headerlink" href="#community-detection" title="Permalink to this headline">#</a></h1>
<p><strong>Community detection</strong> is the process of dividing a network into <strong>communities</strong>, where each community is some subset of nodes which connect more within community than without.
This is an old and famous network science problem. It has applications across a wide
range of disciplines. To name a just a few:</p>
<ul class="simple">
<li><p>Predicting “workgroups” in organizational communication networks <span id="id1">[<a class="reference internal" href="#id59" title="Tiona Zuzul, Emily Cox Pahnke, Jonathan Larson, Patrick Bourke, Nicholas Caurvina, Neha Parikh Shah, Fereshteh Amini, Youngser Park, Joshua Vogelstein, Jeffrey Weston, and others. Dynamic silos: increased modularity in intra-organizational communication networks during the covid-19 pandemic. arXiv preprint arXiv:2104.00641, 2021.">2</a>]</span></p></li>
<li><p>Grouping researchers into fields based on networks of collaboration <span id="id2">[<a class="reference internal" href="#id64" title="Michelle Girvan and Mark EJ Newman. Community structure in social and biological networks. Proceedings of the national academy of sciences, 99(12):7821–7826, 2002.">3</a>]</span></p></li>
<li><p>Clustering networks formed by nearest neighbors in high-dimensional data</p></li>
</ul>
<p>Much of the discussion/derivation in this notebook is based on Sections 7.7 and 14.2
from Mark Newman’s “Networks” <span id="id3">[<a class="reference internal" href="#id43" title="Mark Newman. Networks. Oxford university press, 2018.">1</a>]</span>.</p>
<section id="modularity">
<h2>Modularity<a class="headerlink" href="#modularity" title="Permalink to this headline">#</a></h2>
<p>From <a class="reference external" href="https://en.wikipedia.org/wiki/Modularity">Wikipedia</a>, in general usage, “modularity is the degree to which a system’s components may be separated and recombined.” The <a class="reference external" href="https://en.wikipedia.org/wiki/Modularity_(networks)">definition in network science</a> is similar in spirit but has a more specific meaning. In words, <strong>modularity</strong> it is “the strength of division of a network into modules (also called groups, clusters or communities). Networks with high modularity have dense connections between the nodes within modules but sparse connections between nodes in different modules.”</p>
<p>How do we write this down mathematically? To begin, lets consider an <em>undirected, unweighted</em> network with no loops, with <span class="math notranslate nohighlight">\(n \times n\)</span> adjacency matrix <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>As usual, we’ll let <span class="math notranslate nohighlight">\(k\)</span> be an <span class="math notranslate nohighlight">\(n\)</span>-length vector with the degree of each node. <span class="math notranslate nohighlight">\(m\)</span> will be the total number of edges.</p>
<!-- 
First, we'll create a matrix $B$ defined as

$$B_{ij} = A_{ij} - \frac{k_i}{k_j}{2m}$$ -->
<p>First, we’d like some way of measuring the strength of edges within groups. Let <span class="math notranslate nohighlight">\(\delta(\tau_i, \tau_j)\)</span> be an indicator function which is
1 if <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> are in the same group, and 0 otherwise. Then, the total number of within-community edges is:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2} \sum_{i,j} A_{ij} \delta(\tau_i, \tau_j)\]</div>
<p>Note that we include the factor of <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> because otherwise edges would be counted twice in the sum.</p>
<p>Now, we want to optimize some function of the expression above, but note that as written, we could trivially put
all nodes in the same group and that would maximize the expression we have written. So, we are going to add a term
that will balance how many edges are within a group by how many edges we’d expect within a group based on a random model.</p>
<p>Specifically, we’ll use the random model where each node has its observed degree (<span class="math notranslate nohighlight">\(k_i\)</span>),
but edges are arranged at random. How many edges are expected between nodes under this model?</p>
<p>Consider node <span class="math notranslate nohighlight">\(i\)</span> for the moment, and lets compute the probability of a particular
edge <span class="math notranslate nohighlight">\((i,j)\)</span>. Let’s select <em>one</em> of the edges attached to <span class="math notranslate nohighlight">\(i\)</span>. Note that there are
<span class="math notranslate nohighlight">\(2m-1\)</span> remaining edge stubs (sometimes called half
edges) in the network. If the wiring is random, then the probability of connecting to
any other edge stub is the same. Therefore, the probability of connecting to node <span class="math notranslate nohighlight">\(j\)</span> is
proportional to the degree of that node: <span class="math notranslate nohighlight">\(\frac{k_j}{2m-1}\)</span>. This is the
probability of the original half-edge we chose being connected to <span class="math notranslate nohighlight">\(j\)</span>, but <em>any</em> half-edge
connected to <span class="math notranslate nohighlight">\(i\)</span> could have made the edge <span class="math notranslate nohighlight">\((i, j)\)</span>. And how many of these half-edges
are there? <span class="math notranslate nohighlight">\(k_i\)</span> of them. Therefore, the overall
probability that <span class="math notranslate nohighlight">\(i\)</span> is connected to <span class="math notranslate nohighlight">\(j\)</span> is <span class="math notranslate nohighlight">\(\frac{k_i k_j}{2m-1}\)</span>. Usually since <span class="math notranslate nohighlight">\(m\)</span> is
so large for most networks, we drop the <span class="math notranslate nohighlight">\(-1\)</span> and consider</p>
<div class="math notranslate nohighlight">
\[P_{ij} = \frac{k_i k_j}{2m}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the logic above, we omit some details about multiple edges between the same pair
of nodes under this random model, and the possibility of loops. Like the issue of <span class="math notranslate nohighlight">\(2m\)</span>
vs. <span class="math notranslate nohighlight">\(2m-1\)</span>, these details are negligible as the number of edges/nodes get large, so
we ignore them for simplicity.</p>
</div>
<p>Great, this is roughly the probability of the edge <span class="math notranslate nohighlight">\((i, j)\)</span>, but recall that we were
interested in something like “given a partition <span class="math notranslate nohighlight">\(\tau\)</span> of my network, how many edges
should I expect to be within-group under this silly null model?”. Using the same logic
as before, we can compute this expected value by summing over this expected probability
matrix.</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2} \sum_{ij} \frac{k_i k_j}{2m} \delta(\tau_i, \tau_j)\]</div>
<p>Going back to our original expression, we literally take the difference of the observed
number of edges that are within-group minus the number we’d expect by chance.</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2} \sum_{i,j} A_{ij} \delta(\tau_i, \tau_j) - \frac{1}{2} \sum_{ij} \frac{k_i k_j}{2m} \delta(\tau_i, \tau_j) = \frac{1}{2} \sum_{i,j} \left(A_{ij} - \frac{k_i k_j}{2m} \right ) \delta(\tau_i, \tau_j)\]</div>
<p>Lastly, it is usually more interpretable to make this quantity a proportion of edge rather than
a count, so we divide by <span class="math notranslate nohighlight">\(m\)</span>. Thus, we arrive at the expression usually defined as modularity.</p>
<div class="math notranslate nohighlight">
\[Q(A, \tau) = \frac{1}{2m} \sum_{ij} \left(A_{ij} - \frac{k_i k_j}{2m} \right ) \delta(\tau_i, \tau_j)\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>People often talk about “the modularity of this network” as if it is a function of the
adjacency matrix only: <span class="math notranslate nohighlight">\(Q(A)\)</span>. Note that modularity is absolutely a function of a
network <span class="math notranslate nohighlight">\(A\)</span> AND a partition, <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</div>
<section id="naive-optimization">
<h3>Naive optimization<a class="headerlink" href="#naive-optimization" title="Permalink to this headline">#</a></h3>
<p>Thus far, we’ve talked about how we can compute this modularity quantity for a given
<span class="math notranslate nohighlight">\(A\)</span> and partition <span class="math notranslate nohighlight">\(\tau\)</span>. But remember, we are talking about community <em>detection</em>! In
other words, we’re trying to infer <span class="math notranslate nohighlight">\(\tau\)</span> from the data.</p>
<p>For the next few explanations, we are going to restrict ourselves to the case where we
are only seeking to divide a network into <em>two</em> communities since it will make the
explanations easier, but note that everything still works for more communities.</p>
<div class="tip admonition">
<p class="admonition-title">Question</p>
<p>Let’s say you have <span class="math notranslate nohighlight">\(n\)</span> nodes, and you’re only considering community detection into
two groups. How many different partitions, <span class="math notranslate nohighlight">\(\tau\)</span>, are there?</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

<span class="n">n_possible_taus</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">ns</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="n">sns</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="s2">&quot;talk&quot;</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">n_possible_taus</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Number of nodes&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Number of bipartitions&quot;</span><span class="p">)</span>
<span class="n">world_pop</span> <span class="o">=</span> <span class="mi">8_000_000_000</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">world_pop</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">world_pop</span><span class="p">,</span> <span class="s2">&quot;Number</span><span class="se">\n</span><span class="s2">of people</span><span class="se">\n</span><span class="s2">on Earth</span><span class="se">\n</span><span class="s2">(2022)&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/community_detection_3_0.png" src="_images/community_detection_3_0.png" />
</div>
</div>
<div class="tip admonition">
<p class="admonition-title">Question</p>
<p>Let’s say you have a network <span class="math notranslate nohighlight">\(A\)</span>, and I give you a random partition, <span class="math notranslate nohighlight">\(\tau\)</span>. What is the
silliest, most naive way you can think of trying to improve the modularity score?</p>
</div>
<p>For the next few examples, we’ll use the “polbooks” dataset, available at
<a class="reference external" href="https://networks.skewed.de/net/polbooks#None_draw">Netzschleuder</a>. Each node is a book,
and the nodes are linked by edges which represent “frequent copurchasing of those books
by the same buyers” on Amazon.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="s2">&quot;networks-course/data/polbooks.csv/edges.csv&quot;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>

<span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="n">node_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">nodelist</span><span class="p">)</span>

<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">kamada_kawai_layout</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

<span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
    <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
<span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>

<span class="n">node_df</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xs</span>
<span class="n">node_df</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys</span>

<span class="n">adj</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">node_df</span><span class="p">[</span><span class="s2">&quot;degree&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We’ll start by generating a random <span class="math notranslate nohighlight">\(\tau\)</span> with two communities.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># random bernoullis</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">888</span><span class="p">)</span>
<span class="n">partition</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

<span class="n">partition</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1,
       1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0,
       1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1,
       0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0,
       0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0])
</pre></div>
</div>
</div>
</div>
<p>Clearly this random partition of our network is not very good:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">modularity_from_adjacency</span><span class="p">(</span><span class="n">sym_adj</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">partition_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sym_adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">partition_labels</span> <span class="o">=</span> <span class="n">partition</span>
    <span class="n">partition_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">partition_labels</span><span class="p">)</span>
    <span class="n">in_comm_mask</span> <span class="o">=</span> <span class="n">partition_labels</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="n">partition_labels</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sym_adj</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
    <span class="n">degree_prod_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">degrees</span><span class="p">)</span> <span class="o">/</span> <span class="n">sym_adj</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">mod_mat</span> <span class="o">=</span> <span class="n">sym_adj</span> <span class="o">-</span> <span class="n">resolution</span> <span class="o">*</span> <span class="n">degree_prod_mat</span>
    <span class="k">return</span> <span class="n">mod_mat</span><span class="p">[</span><span class="n">in_comm_mask</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">sym_adj</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>


<span class="n">mod_score</span> <span class="o">=</span> <span class="n">modularity_from_adjacency</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
<span class="n">mod_score</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.014078496099876065
</pre></div>
</div>
</div>
</div>
<p>What would this partition look like plotted on our network?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.plot</span> <span class="kn">import</span> <span class="n">networkplot</span><span class="p">,</span> <span class="n">heatmap</span>

<span class="n">node_df</span><span class="p">[</span><span class="s2">&quot;random_partition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">partition</span>

<span class="k">def</span> <span class="nf">plot_network_partition</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">partition_key</span><span class="p">):</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>

    <span class="n">networkplot</span><span class="p">(</span>
        <span class="n">adj</span><span class="p">,</span>
        <span class="n">x</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
        <span class="n">node_data</span><span class="o">=</span><span class="n">node_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span>
        <span class="n">node_alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="n">edge_alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
        <span class="n">edge_linewidth</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
        <span class="n">node_hue</span><span class="o">=</span><span class="n">partition_key</span><span class="p">,</span>
        <span class="n">node_size</span><span class="o">=</span><span class="s2">&quot;degree&quot;</span><span class="p">,</span>
        <span class="n">edge_hue</span><span class="o">=</span><span class="s2">&quot;source&quot;</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="n">_</span> <span class="o">=</span> <span class="n">heatmap</span><span class="p">(</span>
        <span class="n">adj</span><span class="p">,</span>
        <span class="n">inner_hier_labels</span><span class="o">=</span><span class="n">node_data</span><span class="p">[</span><span class="n">partition_key</span><span class="p">],</span>
        <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;Purples&quot;</span><span class="p">,</span>
        <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sort_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

<span class="n">plot_network_partition</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_df</span><span class="p">,</span> <span class="s1">&#39;random_partition&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&lt;Figure size 1080x504 with 4 Axes&gt;,
 &lt;AxesSubplot:xlabel=&#39;Number of nodes&#39;, ylabel=&#39;Number of bipartitions&#39;&gt;)
</pre></div>
</div>
<img alt="_images/community_detection_12_1.png" src="_images/community_detection_12_1.png" />
</div>
</div>
<p>Next we’ll try a very simple algorithm for maximizing modularity. Starting from some
initial partition <span class="math notranslate nohighlight">\(\tau_0\)</span>, we proceed by simply picking a node at random, and then
check whether switching the group assigned to that node increases the modularity. If it
does, we move that node into that group. Otherwise, we revert it back to its original
group label, and proceed to the next iteration of checking another random node’s label.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_trials</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="n">best_scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">best_iterations</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">last_mod_score</span> <span class="o">=</span> <span class="n">mod_score</span>
<span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trials</span><span class="p">):</span>
    <span class="c1"># choose a random node to perturb</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># check what group it is currently in, and swap it</span>
    <span class="n">current_group</span> <span class="o">=</span> <span class="n">partition</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">current_group</span><span class="p">:</span>
        <span class="n">partition</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">partition</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># compute modularity with this slightly modified partition</span>
    <span class="n">mod_score</span> <span class="o">=</span> <span class="n">modularity_from_adjacency</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>

    <span class="c1"># decide whether to keep that change or not</span>
    <span class="k">if</span> <span class="n">mod_score</span> <span class="o">&lt;</span> <span class="n">last_mod_score</span><span class="p">:</span>
        <span class="c1"># swap it back</span>
        <span class="k">if</span> <span class="n">current_group</span><span class="p">:</span>
            <span class="n">partition</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">partition</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">last_mod_score</span> <span class="o">=</span> <span class="n">mod_score</span>
        <span class="n">best_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mod_score</span><span class="p">)</span>
        <span class="n">best_iterations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

<span class="n">mod_score</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.4405468914701179
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">partition</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
       1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0])
</pre></div>
</div>
</div>
</div>
<p>Below, we look at how modularity changes as this simple algorithm progresses through
its iterations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">best_iterations</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">best_scores</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Modularity&quot;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Iteration&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/community_detection_17_0.png" src="_images/community_detection_17_0.png" />
</div>
</div>
<p>Let’s look at the partition we find when plotted over the network.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">node_df</span><span class="p">[</span><span class="s2">&quot;naive_partition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">partition</span>

<span class="n">plot_network_partition</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_df</span><span class="p">,</span> <span class="s1">&#39;naive_partition&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&lt;Figure size 1080x504 with 4 Axes&gt;,
 &lt;AxesSubplot:xlabel=&#39;Iteration&#39;, ylabel=&#39;Modularity&#39;&gt;)
</pre></div>
</div>
<img alt="_images/community_detection_19_1.png" src="_images/community_detection_19_1.png" />
</div>
</div>
</section>
<section id="spectral-optimization">
<h3>Spectral optimization<a class="headerlink" href="#spectral-optimization" title="Permalink to this headline">#</a></h3>
<p>Next, we’ll look at one less silly way of optimizing modularity.</p>
<p>We can define the matrix <span class="math notranslate nohighlight">\(B\)</span>, often called the <strong>modularity matrix</strong> as</p>
<div class="math notranslate nohighlight">
\[B_{ij} = A_{ij} - \frac{k_i k_j}{2m} \]</div>
<p>Sticking to the case of two groups, let’s change our convention for <span class="math notranslate nohighlight">\(\tau\)</span> so that
<span class="math notranslate nohighlight">\(\tau_i = 1\)</span> if node <span class="math notranslate nohighlight">\(i\)</span> is in group 1, and <span class="math notranslate nohighlight">\(\tau_i = -1\)</span> if it is in group 2.</p>
<p>Then, note that our indicator function has a nice expression now:</p>
<div class="math notranslate nohighlight">
\[\delta(\tau_i, \tau_j) = \frac{1}{2} (\tau_i \tau_j + 1)\]</div>
<p>Now we can easily write our modularity function.</p>
<div class="math notranslate nohighlight">
\[Q(A, \tau) = \frac{1}{4m} \sum_{ij} B_{ij} \tau_i \tau_j\]</div>
<p>In matrix/vector form, we can write this as</p>
<div class="math notranslate nohighlight">
\[Q(A, \tau) = \frac{1}{4m} \tau^T B \tau\]</div>
<p>Note that <span class="math notranslate nohighlight">\(B\)</span> is still a symmetric matrix (since we were concerned with undirected graphs).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.utils</span> <span class="kn">import</span> <span class="n">is_symmetric</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">modularity_matrix</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">)</span>

<span class="n">is_symmetric</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Next, we proceed by making an approximation. We have a discrete optimization problem:</p>
<div class="math notranslate nohighlight">
\[\max_{\tau \text{ s.t. } \tau_i \in \{-1, 1\}} \tau^T B \tau\]</div>
<p>This is a difficult problem because of how many possible <span class="math notranslate nohighlight">\(\tau\)</span>s there are as we saw
before, and the discrete nature of the problem. Note that <span class="math notranslate nohighlight">\(\| \tau \|_2\)</span>, the Euclidean
norm of <span class="math notranslate nohighlight">\(\tau\)</span>, will always be <span class="math notranslate nohighlight">\(\sqrt{n}\)</span>. We relax our problem so that <span class="math notranslate nohighlight">\(\tau\)</span> does not
have to be discrete, but keeps its length.</p>
<div class="math notranslate nohighlight">
\[\max_{\tau \text{ s.t. } \| \tau \| = \sqrt{n}} \tau^T B \tau\]</div>
<p>This problem has the same solution (ignoring constants that don’t affect the result besides
scaling):</p>
<div class="math notranslate nohighlight">
\[R(B, \tau) = \max_{\tau} \frac{\tau^T B \tau}{\tau^T \tau}\]</div>
<p>Note that this expression is what’s known as a
<a class="reference external" href="https://en.wikipedia.org/wiki/Rayleigh_quotient">Rayleigh-Ritz ratio or Rayleigh quotient</a>.
We won’t go into deriving the properties of this, but note that if you know what an
eigendecomposition is, it is not to difficult to work out the following property: for a
symmetric matrix <span class="math notranslate nohighlight">\(B\)</span> in the expression above, <span class="math notranslate nohighlight">\(R(B, \tau) \in [\lambda_{min}, \lambda_{max}]\)</span> where
<span class="math notranslate nohighlight">\(\lambda_{min}\)</span> and <span class="math notranslate nohighlight">\(\lambda_{max}\)</span> are the smallest and largest eigenvalues of <span class="math notranslate nohighlight">\(B\)</span>, respectively.</p>
<p>So, this tells us that the maximum is achieved when <span class="math notranslate nohighlight">\(R(B, \tau) = \lambda_{max}\)</span>. And how
can we achieve this upper bound? By setting <span class="math notranslate nohighlight">\(\tau\)</span> to be the eigenvector corresponding
to the largest eigenvalue (call this <span class="math notranslate nohighlight">\(x\)</span>):</p>
<div class="math notranslate nohighlight">
\[\frac{\tau^T B \tau}{\tau^T \tau} = \frac{x^T B x}{x^T x} = \frac{x^T \lambda_{max} x}{x^T x} = \lambda_{max} \frac{x^T  x}{x^T x} = \lambda_{max}\]</div>
<p>However, now we need to get back to our discrete optimization problem by projecting back onto
the discrete solutions, e.g. where <span class="math notranslate nohighlight">\(\tau\)</span> is only <span class="math notranslate nohighlight">\(-1\)</span> or <span class="math notranslate nohighlight">\(1\)</span>. To do so, we maximize the
inner products between this discrete solution, <span class="math notranslate nohighlight">\(\tau\)</span>, and our eigenvector <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="math notranslate nohighlight">
\[x^T \tau = \sum_i x_i \tau_i\]</div>
<p>To do so, we want <span class="math notranslate nohighlight">\(x_i \tau_i\)</span> to be positive for all <span class="math notranslate nohighlight">\(i\)</span>. We can achieve this by
setting</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\tau_{i} = \begin{cases}
1 \text{   if } x_i &gt; 0 \\
-1 \text{ if } x_i \leq 0
\end{cases}
\end{split}\]</div>
<p>Thus, our simple algorithm is now to:</p>
<ol class="simple">
<li><p>Compute the eigenvector corresponding to the largest eigenvalue of <span class="math notranslate nohighlight">\(B\)</span>, and</p></li>
<li><p>Threshold the corresponding eigenvector based on its sign to get our partition.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be careful about assuming the order in which eigenvalues/eigenvectors are returned.</p>
<p>Here, they are returned in <em>decreasing</em> order by the <code class="docutils literal notranslate"><span class="pre">eigh</span></code> function, which is faster
for symmetric (Hermitian) matrices.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="n">first_eigenvector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">first_eigenvector</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-0.02550912, -0.02456848, -0.00170053, -0.19262125,  0.01632424,
       -0.02333085, -0.05243838,  0.01705257, -0.23826617, -0.14694971,
       -0.13066785, -0.17909148, -0.2278586 , -0.13652453, -0.09609015,
       -0.0537466 , -0.03258368, -0.07848085, -0.04078242, -0.02814099,
       -0.09584042, -0.07332282, -0.07773025, -0.11014213, -0.11975091,
       -0.05089722, -0.11127976, -0.12026225,  0.03486849, -0.03053454,
        0.18966993,  0.10967268, -0.07009965, -0.10030317, -0.08262   ,
       -0.03008297, -0.0535839 , -0.07084867, -0.06221648, -0.0758389 ,
       -0.1696462 , -0.10436962, -0.07279506, -0.04798468, -0.07367568,
       -0.08792768, -0.05454009, -0.17501516, -0.0219253 ,  0.01486383,
       -0.02666456, -0.00957711, -0.01668981, -0.03091357, -0.07826915,
       -0.03811773, -0.02425889, -0.02312067,  0.01822838,  0.04866926,
        0.02113664,  0.0199537 ,  0.04687952,  0.01967049,  0.02755088,
        0.01022675,  0.19268054,  0.03578428,  0.01618876,  0.0036785 ,
        0.08375239,  0.13868297,  0.2027985 ,  0.21677572,  0.18442602,
        0.17949498,  0.14169565,  0.06326878,  0.06912215,  0.11280441,
        0.0614348 ,  0.04966937,  0.13492524,  0.10857716,  0.22677681,
        0.03713454,  0.14403887,  0.06610225,  0.07608982,  0.08987874,
        0.05797735,  0.08678585,  0.05088125,  0.07853913,  0.05733061,
        0.02542713,  0.07555278,  0.07673903,  0.0571795 ,  0.1187217 ,
        0.12131853,  0.04811651,  0.00866984,  0.00311235,  0.00329647])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eig_partition</span> <span class="o">=</span> <span class="n">first_eigenvector</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">eig_partition</span><span class="p">[</span><span class="n">eig_partition</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">eig_partition</span><span class="p">[</span><span class="n">eig_partition</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">eig_partition</span> <span class="o">=</span> <span class="n">eig_partition</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eig_partition</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
</pre></div>
</div>
</div>
</div>
<p>How does this partition compare to our earlier one?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">modularity_from_adjacency</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.44240825581933463
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">node_df</span><span class="p">[</span><span class="s2">&quot;eig_partition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_partition</span>

<span class="n">plot_network_partition</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_df</span><span class="p">,</span> <span class="s1">&#39;eig_partition&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&lt;Figure size 1080x504 with 4 Axes&gt;,
 &lt;AxesSubplot:xlabel=&#39;Iteration&#39;, ylabel=&#39;Modularity&#39;&gt;)
</pre></div>
</div>
<img alt="_images/community_detection_30_1.png" src="_images/community_detection_30_1.png" />
</div>
</div>
</section>
<section id="agglomerative-optimization-louvain-leiden">
<h3>Agglomerative optimization - Louvain/Leiden<a class="headerlink" href="#agglomerative-optimization-louvain-leiden" title="Permalink to this headline">#</a></h3>
<p>We won’t get into as much detail about more complicated methods for optimizing the
modularity, but I wanted to mention these algorithms since they are somewhat
state-of-the-art.</p>
<figure class="align-default" id="louvain">
<img alt="_images/louvain.png" src="_images/louvain.png" />
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">High-level summary of the Louvain algorithm <span id="id4">[<a class="reference internal" href="#id61" title="Vincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne Lefebvre. Fast unfolding of communities in large networks. Journal of statistical mechanics: theory and experiment, 2008(10):P10008, 2008.">4</a>]</span>. Figure from the
Leiden paper <span id="id5">[<a class="reference internal" href="#id60" title="Vincent A Traag, Ludo Waltman, and Nees Jan Van Eck. From louvain to leiden: guaranteeing well-connected communities. Scientific reports, 9(1):1–12, 2019.">5</a>]</span>, which further improved the Louvain algorithm.</span><a class="headerlink" href="#louvain" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The Leiden algorithm scales to very large networks, and usually provides competitive
modularity scores. It is easy to use from <code class="docutils literal notranslate"><span class="pre">graspologic</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.partition</span> <span class="kn">import</span> <span class="n">leiden</span><span class="p">,</span> <span class="n">modularity</span>

<span class="n">leiden_partition_map</span> <span class="o">=</span> <span class="n">leiden</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="nb">type</span><span class="p">(</span><span class="n">leiden_partition_map</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>dict
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># this is necessary just because this modularity implementation assumes a weighted graph</span>
<span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span> 

<span class="n">modularity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">leiden_partition_map</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.5264061784955857
</pre></div>
</div>
</div>
</div>
<p>Note that this algorithm (like most) is not deterministic.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">leiden_partition_map</span> <span class="o">=</span> <span class="n">leiden</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">modularity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">leiden_partition_map</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.5266195669499848
</pre></div>
</div>
</div>
</div>
<p>Often, it’s a good idea to take the best over multiple runs of the algorithm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">leiden_partition_map</span> <span class="o">=</span> <span class="n">leiden</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">trials</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">modularity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">leiden_partition_map</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.5270746242563541
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">node_df</span><span class="p">[</span><span class="s1">&#39;leiden_partition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">leiden_partition_map</span><span class="p">)</span>

<span class="n">plot_network_partition</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_df</span><span class="p">,</span> <span class="s1">&#39;leiden_partition&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&lt;Figure size 1080x504 with 4 Axes&gt;,
 &lt;AxesSubplot:xlabel=&#39;Iteration&#39;, ylabel=&#39;Modularity&#39;&gt;)
</pre></div>
</div>
<img alt="_images/community_detection_39_1.png" src="_images/community_detection_39_1.png" />
</div>
</div>
</section>
<section id="know-what-modularity-gives-you">
<h3>Know what modularity gives you<a class="headerlink" href="#know-what-modularity-gives-you" title="Permalink to this headline">#</a></h3>
<p>I briefly want to mention one point of confusion I’ve seen, in particular when thinking
about stochastic block models (SBM) and community detection.</p>
<p>I always refer to community detection to mean “finding <strong>assortative</strong> or <strong>homophillic</strong>
groups of nodes.” Both of these terms just mean “like connects to like.” Conversely,
other algorithms might be able to find <strong>disassortative</strong> groups of nodes, which I
would not call communities.</p>
<p>Let’s see how community detection performs in both of these cases.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.simulations</span> <span class="kn">import</span> <span class="n">sbm</span> 

<span class="n">B_assort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]])</span>
<span class="n">B_disassort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]])</span>

<span class="n">A_assort</span><span class="p">,</span> <span class="n">labels_assort</span> <span class="o">=</span> <span class="n">sbm</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span> <span class="n">B_assort</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">A_disassort</span><span class="p">,</span> <span class="n">labels_disassort</span> <span class="o">=</span> <span class="n">sbm</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span> <span class="n">B_disassort</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">nodelist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="n">partition_map_assort</span> <span class="o">=</span> <span class="n">leiden</span><span class="p">(</span><span class="n">A_assort</span><span class="p">,</span> <span class="n">trials</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">partition_map_disassort</span> <span class="o">=</span> <span class="n">leiden</span><span class="p">(</span><span class="n">A_disassort</span><span class="p">,</span> <span class="n">trials</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">partition_assort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">partition_map_assort</span><span class="o">.</span><span class="n">get</span><span class="p">)(</span><span class="n">nodelist</span><span class="p">)</span>
<span class="n">partition_disassort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">partition_map_disassort</span><span class="o">.</span><span class="n">get</span><span class="p">)(</span><span class="n">nodelist</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

<span class="n">heatmap_kws</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">heatmap</span><span class="p">(</span><span class="n">A_assort</span><span class="p">,</span> <span class="n">inner_hier_labels</span><span class="o">=</span><span class="n">labels_assort</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">heatmap_kws</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;True partition&#39;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Assortative SBM&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">heatmap</span><span class="p">(</span><span class="n">A_disassort</span><span class="p">,</span> <span class="n">inner_hier_labels</span><span class="o">=</span><span class="n">labels_disassort</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">heatmap_kws</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Disassortative SBM&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">heatmap</span><span class="p">(</span><span class="n">A_assort</span><span class="p">,</span> <span class="n">inner_hier_labels</span><span class="o">=</span><span class="n">partition_assort</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">heatmap_kws</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Estimated partition&#39;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">heatmap</span><span class="p">(</span><span class="n">A_disassort</span><span class="p">,</span> <span class="n">inner_hier_labels</span><span class="o">=</span><span class="n">partition_disassort</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">heatmap_kws</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/community_detection_41_0.png" src="_images/community_detection_41_0.png" />
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Other families of algorithms <em>would</em> be able to find this disassortative
partition - it’s just not what modularity is looking for.</p>
</div>
</section>
<section id="issues-with-modularity-maximization">
<h3>Issues with modularity maximization<a class="headerlink" href="#issues-with-modularity-maximization" title="Permalink to this headline">#</a></h3>
<section id="resolution-limit">
<h4>Resolution limit<a class="headerlink" href="#resolution-limit" title="Permalink to this headline">#</a></h4>
<p>While these algorithms are very useful, they have problems. The first is called the
<a class="reference external" href="https://en.wikipedia.org/wiki/Modularity_(networks)#Resolution_limit">resolution limit</a>.
This idea is basically that for a large network, small communities (even if very clear)
can be impossible to detect for any modularity maximization algorithm. There is further
discussion of this issue in Section 14.2.6 of Newman’s Networks book.</p>
</section>
<section id="overfitting">
<h4>Overfitting<a class="headerlink" href="#overfitting" title="Permalink to this headline">#</a></h4>
<p>Modularity maximization algorithms can also have the converse problem, that is, finding
community structure when it is not present. This is best demonstrated by example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.simulations</span> <span class="kn">import</span> <span class="n">er_np</span>

<span class="n">n_nodes</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">A_er</span> <span class="o">=</span> <span class="n">er_np</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="n">leiden_partition_map</span> <span class="o">=</span> <span class="n">leiden</span><span class="p">(</span><span class="n">A_er</span><span class="p">)</span>

<span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)</span>
<span class="n">partition_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">leiden_partition_map</span><span class="o">.</span><span class="n">get</span><span class="p">)(</span><span class="n">nodes</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">heatmap</span><span class="p">(</span><span class="n">A_er</span><span class="p">,</span> <span class="n">inner_hier_labels</span><span class="o">=</span><span class="n">partition_labels</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/community_detection_44_0.png" src="_images/community_detection_44_0.png" />
</div>
</div>
<p>Even for this very simple, completely random (Erdos-Renyi) network, Leiden found several
communities - further, these communities <em>do</em> look more densely connected within.
However, the key point here is that these “communities” arose completely by chance even
with the simplest null model.</p>
</section>
</section>
</section>
<section id="alternatives-to-modularity">
<h2>Alternatives to modularity<a class="headerlink" href="#alternatives-to-modularity" title="Permalink to this headline">#</a></h2>
<p>While we haven’t had time to discuss them, there are many alternatives to modularity
maximization for finding communities. For instance:</p>
<section id="infomap">
<h3>InfoMap<a class="headerlink" href="#infomap" title="Permalink to this headline">#</a></h3>
<p>InfoMap uses random walks and an information theory framework. The idea is
that good communities should allow you to easily compress the amount of information that
would be required to encode the path of a random walker.</p>
<figure class="align-default" id="id77">
<img alt="_images/metadatamapequation.svg" src="_images/metadatamapequation.svg" /><figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">Illustration of the idea of encoding the path of random walkers used by InfoMap.
Figure from <span id="id6">Emmons and Mucha [<a class="reference internal" href="#id62" title="Scott Emmons and Peter J Mucha. Map equation with metadata: varying the role of attributes in community detection. Physical Review E, 100(2):022301, 2019.">6</a>]</span>.</span><a class="headerlink" href="#id77" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="statistical-inference-sbm-similar">
<h3>Statistical inference (SBM + similar)<a class="headerlink" href="#statistical-inference-sbm-similar" title="Permalink to this headline">#</a></h3>
<figure class="align-default" id="id78">
<img alt="_images/peixoto-community.png" src="_images/peixoto-community.png" />
<figcaption>
<p><span class="caption-number">Fig. 8 </span><span class="caption-text">Demonstration of how inferring a statistical model (like an assortative SBM) can
alleviate some of the issues from modularity maximization. Figure from <span id="id7">Peixoto [<a class="reference internal" href="#id63" title="Tiago P Peixoto. Descriptive vs. inferential community detection: pitfalls, myths and half-truths. arXiv preprint arXiv:2112.00183, 2021.">7</a>]</span>.</span><a class="headerlink" href="#id78" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="other-code">
<h2>Other code<a class="headerlink" href="#other-code" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://cdlib.readthedocs.io/en/latest/">CDlib</a> has a wide range of community detection algorithms.</p></li>
<li><p><a class="reference external" href="https://networkx.org/documentation/stable/reference/algorithms/community.html">NetworkX’s community section</a> has a few algorithms.</p></li>
<li><p><a class="reference external" href="https://graph-tool.skewed.de/static/doc/demos/inference/inference.html#assortative-community-structure">graph-tool</a> has some new tools for assortative community detection based on statistical models.</p></li>
</ul>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h2>
<div class="docutils container" id="id8">
<dl class="citation">
<dt class="label" id="id43"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>Mark Newman. <em>Networks</em>. Oxford university press, 2018.</p>
</dd>
<dt class="label" id="id59"><span class="brackets"><a class="fn-backref" href="#id1">2</a></span></dt>
<dd><p>Tiona Zuzul, Emily Cox Pahnke, Jonathan Larson, Patrick Bourke, Nicholas Caurvina, Neha Parikh Shah, Fereshteh Amini, Youngser Park, Joshua Vogelstein, Jeffrey Weston, and others. Dynamic silos: increased modularity in intra-organizational communication networks during the covid-19 pandemic. <em>arXiv preprint arXiv:2104.00641</em>, 2021.</p>
</dd>
<dt class="label" id="id64"><span class="brackets"><a class="fn-backref" href="#id2">3</a></span></dt>
<dd><p>Michelle Girvan and Mark EJ Newman. Community structure in social and biological networks. <em>Proceedings of the national academy of sciences</em>, 99(12):7821–7826, 2002.</p>
</dd>
<dt class="label" id="id61"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Vincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne Lefebvre. Fast unfolding of communities in large networks. <em>Journal of statistical mechanics: theory and experiment</em>, 2008(10):P10008, 2008.</p>
</dd>
<dt class="label" id="id60"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Vincent A Traag, Ludo Waltman, and Nees Jan Van Eck. From louvain to leiden: guaranteeing well-connected communities. <em>Scientific reports</em>, 9(1):1–12, 2019.</p>
</dd>
<dt class="label" id="id62"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>Scott Emmons and Peter J Mucha. Map equation with metadata: varying the role of attributes in community detection. <em>Physical Review E</em>, 100(2):022301, 2019.</p>
</dd>
<dt class="label" id="id63"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p>Tiago P Peixoto. Descriptive vs. inferential community detection: pitfalls, myths and half-truths. <em>arXiv preprint arXiv:2112.00183</em>, 2021.</p>
</dd>
</dl>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="random_graphs.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Random network models</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="embedding.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Network embedding</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Benjamin D. Pedigo<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>